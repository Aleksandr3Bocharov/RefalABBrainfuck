* Copyright 2024 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt
* or copy at http://www.boost.org/LICENSE_1_0.txt
* 2024-06-12
* https://github.com/Aleksandr3Bocharov/r2brainfuck

*====================================================================
* r2brainfuck
*
* Программа "r2brainfuck" написана
* на языке программирования Рефал-2.
* http://www.refal.net/~belous/refal2-r.htm
*
* Программа "r2brainfuck" использует
* библиотеку расширения Рефал-2.
* https://github.com/Aleksandr3Bocharov/r2libext
*
* Программа "r2brainfuck" использует 
* библиотеку GTK3.
* https://docs.gtk.org/gtk3/
*
* Программа "r2brainfuck" интерпретирует код
* на языке Brainfuck из исходного файла.
*====================================================================

            START
            ENTRY Go
            EMPTY Next, Prev, Inc, Dec, Write, Read
* from r2libext
            EXTRN Map, MapAccum, DelAccum, LoadFile
* from r2brainfuckc
*           EXTRN PutChar, GetChar, GTKInit, OpenFileDialog, MessageBox
* from r2lib
            EXTRN Prout, M1, P1, Symb, Br, Dg

* Вывод справки
Help        = <Prout 'The programm "r2brainfuck" interprets code ' +
            'on the language Brainfuck from source file.\n'>

/*

<Interpretator e.Parsing_Tree> == 

e.Parsing_Tree ::= t.LeafNode*
t.LeafNode ::= s.Leaf | (t.LeafNode*)
s.Leaf ::= Next | Prev | Inc | Dec | Write | Read

*/
Interpretator {
    e.Parsing_Tree,
    <DoInterpretator e.Parsing_Tree () 0 ()>: e.Cells =
  }
  
  DoInterpretator {
    (e.BeforeCells) s.Cell (e.AfterCells) =
      (e.BeforeCells) s.Cell (e.AfterCells);
    Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell () =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) 0 ()>;
    Next e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (s.NextCell e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells s.Cell) s.NextCell (e.AfterCells)>;    
    Prev e.Rest_Parsing_Tree () s.Cell (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree () 0 (s.Cell e.AfterCells)>;
    Prev e.Rest_Parsing_Tree (e.BeforeCells s.PrevCell) s.Cell (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.PrevCell (s.Cell e.AfterCells)>;    
    Inc e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
    Inc e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Inc s.Cell> (e.AfterCells)>;     							
    Dec e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 255 (e.AfterCells)>;
    Dec e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Dec s.Cell> (e.AfterCells)>;    
    Write e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
      <PutChar <Chr s.Cell>> 
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells)>;												
    Read e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) <Ord <GetChar>> (e.AfterCells)>;						
    (e.LeafNode) e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells) =
      <DoInterpretator e.Rest_Parsing_Tree (e.BeforeCells) 0 (e.AfterCells)>;
    (e.LeafNode) e.Rest_Parsing_Tree (e.BeforeCells) s.Cell (e.AfterCells),
    <DoInterpretator e.LeafNode (e.BeforeCells) s.Cell (e.AfterCells)>: e.Cells =
      <DoInterpretator (e.LeafNode) e.Rest_Parsing_Tree e.Cells>   
  }

* <Parser E('><+-.,[]')T> == WN*
* WN ::= S(/Next/ /Prev/ /Inc/ /Dec/ /Write/ /Read/)L | (WN*)
Parser +
            =
    '>' ER  = /Next/ <Parser ER>
    '<' ER  = /Prev/ <Parser ER>
    '+' ER  = /Inc/ <Parser ER>
    '-' ER  = /Dec/ <Parser ER>
    '.' ER  = /Write/ <Parser ER>
    ',' ER  = /Read/ <Parser ER>
    '[' ER  = <ParserAux <Parser ER>>
    ']' ER  = (ER)      

ParserAux +
    EP (ER) = (EP) <Parser ER>

* <Tokenizer (SS S(N)R S(N)C)*> == E('><+-.,[]')T | 'Fails' (V(O)E)+
Tokenizer +
    ES      = <TokenizerAux  +
            <Map /DoTokenizer/ ES> (<Dg 'Fails11'> <Dg 'Fails12'>)>

TokenizerAux +
    ET ()   = ET
    ET (EE) = 'Fails' EE
  
DoTokenizer +
    ('[' SR SC) +
            = <Br 'Fails12' '=' <Dg 'Fails12'> +
            ('SYNTAX_ERROR(12): ' +
            'Not exist symbol '']'' for symbol ''['' ' +
            'on the row: ' <Symb SR> ' and column: ' <Symb SC> '.')> +
            '['
    (']' SR SC) +
            = <DoTokenizerAux SR SC <Dg 'Fails12'>>
    (S('><+-.,')S SR SC) + 
            = SS 
    (SS SR SC) +
            =

DoTokenizerAux +
    SR SC   = <Br 'Fails11' '=' <Dg 'Fails11'> +
            ('SYNTAX_ERROR(11): ' +
            'Unexpected symbol '']'' ' +
            'on the row: ' <Symb SR> ' and column: ' <Symb SC> '.')>
    SR SC E2 (EF) +
            = <Br 'Fails12' '=' E2> ']'

IfTokenizer +
* Если Fails, то завершение программы
    'Fails' EE +
            = <Prout 'FATAL_ERROR (99): ' +'
            'There are one or more syntax errors.'> +
            <Map /DoProutLine/ EE>
* Запуск синтаксического анализатора 
    ET      = <Br 'e.ParsingTree' '=' +
            <Parser ET>> +
* Запуск интерпретатора
            <Prout 'The running of the interpretator ' +
            'of the code on the Brainfuck language.\n'> 
*            <Interpretator <Dg 'e.ParsingTree'>>

DoRows +
    SR (EL) = <P1 SR> +
            <DelAccum <MapAccum /DoColumns/ (SR /1/) EL>>	
              
DoColumns +
    (SR SC) SS +
            = (SR <P1 SC>) +
            (SS SR SC)

DoProutLine +
    (EL)    = <Prout EL>

Go          = <Help> +
            <Prout 'The opening of the file "Test.b" ' +
            'with code on the Brainfuck language.\n'> +
* Загрузка строк файла в E.Lines := (E(O)L)*
            <Br 'E.Lines' '=' +
            <LoadFile /0/ 'Test.b'>> +
* Преобразование E.Lines в E.Symbols := (S(O)S S(N)R S(N)C)* 
            <Br 'E.Symbols' '=' +
            <DelAccum <MapAccum /DoRows/ /1/ <Dg 'E.Lines'>>>> +
* Запуск лексического анализатора
            <IfTokenizer <Tokenizer <Dg 'E.Symbols'>>>

            END