* Copyright 2025 Aleksandr Bocharov
* Distributed under the Boost Software License, Version 1.0.
* See accompanying file LICENSE_1_0.txt
* or copy at http://www.boost.org/LICENSE_1_0.txt
* 2025-04-18
* https://github.com/Aleksandr3Bocharov/RefalABBrainfuck

*====================================================================
* RefalABBrainfuck
*
* Программа "RefalABBrainfuck" написана
* на языке программирования РефалАБ.
* https://github.com/Aleksandr3Bocharov/RefalAB
*
* Интерпретатор языка программирования Brainfuck
* на РефалАБ.
*
* Программа "RefalABBrainfuck" интерпретирует 
* код на языке Brainfuck из исходного файла.
*====================================================================

RefalABBrainfuck +
    START
    ENTRY Go
    EXTRN Put_Char, Get_Char
    EXTRN Prout, M1, P1, Symb, Br, Dg
    EXTRN Map, Map_Accumulator, Del_Accumulator, Load_File, Exist_File
    EXTRN Platform, System, Arg, Exit
    EXTRN Windows, True, False
    EMPTY Lines, Fails, Fails11, Fails12, Parsing_Tree
    EMPTY Next, Prev, Inc, Dec, Write, Read

Go      = <chcp_UTF8 <Platform>> <Help> +
        <Args (<Arg /1/>) <Arg /2/>> +
* Запуск лексического анализатора
        <If_Tokenizer <Tokenizer <Symbols <Dg /Lines/>>>>

* Смена кодовой страницы в Windows на UTF-8
chcp_UTF8
    /Windows/ +
        = <chcp_UTF8_Aux <System 'chcp 65001'>> 
    E._ =

chcp_UTF8_Aux
    E._ =

* Вывод справки
Help    = <Prout 'Интерпретатор языка ' +
        'программирования Brainfuck на РефалАБ.\n\n' +
        'Программа "RefalABBrainfuck" ' + 
        'интерпретирует код на языке Brainfuck ' +
        'из исходного файла.\n'>

Args    
    (E._) V.__ +
        = <Args_Error>
    ()  = <Args_Error>
    (E.FileName) +
        = <Open_File <Exist_File E.FileName> E.FileName>

Args_Error
        = <Prout 'FATAL_ERROR (9): ' +
        'Синтаксис - RefalABBrainfuck имя_файла\n'> +
        <Exit /9/>

Open_File
    /False/ E.FileName +
        = <Prout 'FATAL_ERROR (19): ' +
        'Исходный файл "' E.FileName '" не существует.\n'> +
        <Exit /19/>
    /True/ E.FileName +
        = <Prout 'Открытие исходного файла "' E.FileName '" ' +
        'с кодом на языке программирования ' +
        'Brainfuck.\n'> +
* Загрузка строк файла в E.Lines := (E(O).Line)*
        <Br /Lines/ '=' <Load_File /0/ E.FileName>>

* <Symbols (E(O).Line)*> == (O.Symbol N.Row N.Column)*
Symbols
    E.Lines +
        = <Del_Accumulator <Map_Accumulator /Do_Rows/ /1/ E.Lines>>

Do_Rows
    S.Row (E.Line) +
        = <P1 S.Row> +
        <Del_Accumulator <Map_Accumulator /Do_Columns/ (S.Row /1/) E.Line>>	
                      
Do_Columns
    (S.Row S.Column) S.Symbol +
        = (S.Row <P1 S.Column>) (S.Symbol S.Row S.Column)

If_Tokenizer
* Если Fails, то завершение программы
    /Fails/ E.Errors +
        = <Prout 'FATAL_ERROR (99): ' +
        'Имеется одна или больше ' +
        'синтаксических ошибок.'> +
        <Map /Do_Prout_Line/ E.Errors> +
        <Prout> +
        <Exit /99/>
* Запуск синтаксического анализатора 
    E.Tokens +
        = <Br /Parsing_Tree/ '=' <Parser E.Tokens>> +
* Запуск интерпретатора
        <Prout 'Запуск интерпретатора кода ' +
        'на языке программирования Brainfuck.\n'> +
        <Interpretator <Dg /Parsing_Tree/>>

Do_Prout_Line
    (E.Line) +
        = <Prout E.Line>

* <Tokenizer (O.Symbol N.Row N.Column)*> == E('><+-.,[]').Tokens |
*                                           /Fails/ (V(O).Error)+
Tokenizer
    E.Symbols +
        = <Tokenizer_Aux +
        <Map /Do_Tokenizer/ E.Symbols> +
        (<Dg /Fails11/> <Dg /Fails12/>)>

Tokenizer_Aux
    E.Tokens () +
        = E.Tokens
    E._ (E.Errors) +
        = /Fails/ E.Errors
  
Do_Tokenizer
    ('[' S.Row S.Column) +
        = <Br /Fails12/ '=' <Dg /Fails12/> +
        ('SYNTAX_ERROR(12): ' +
        'Не существует символа '']'' ' +
        'для символа ''['' ' +
        'на строке: ' <Symb S.Row> +
        ' и колонке: ' <Symb S.Column> '.')> +
        '['
    (']' E.RowColumn) +
        = <Do_Tokenizer_Aux E.RowColumn <Dg /Fails12/>>
    (S('><+-.,').Symbol E._) + 
        = S.Symbol
    E._ =

Do_Tokenizer_Aux
    S.Row S.Column +
        = <Br /Fails11/ '=' <Dg /Fails11/> +
        ('SYNTAX_ERROR(11): ' +
        'Неожиданный символ '']'' ' +
        'на строке: ' <Symb S.Row> +
        ' и колонке: ' <Symb S.Column> '.')>
    S.Row S.Column E.Fails12_B W.Fail12 +
        = <Br /Fails12/ '=' E.Fails12_B> ']'

* <Parser E('><+-.,[]').Tokens> == W.Node*
* W.Node ::= S(/Next/ /Prev/ /Inc/ /Dec/ /Write/ /Read/).Leaf | (W.Node*)
Parser  =
    '>' E.Rest_Tokens +
        = /Next/ <Parser E.Rest_Tokens>
    '<' E.Rest_Tokens +
        = /Prev/ <Parser E.Rest_Tokens>
    '+' E.Rest_Tokens +
        = /Inc/ <Parser E.Rest_Tokens>
    '-' E.Rest_Tokens +
        = /Dec/ <Parser E.Rest_Tokens>
    '.' E.Rest_Tokens +
        = /Write/ <Parser E.Rest_Tokens>
    ',' E.Rest_Tokens +
        = /Read/ <Parser E.Rest_Tokens>
    '[' E.Rest_Tokens +
        = <Parser_Aux <Parser E.Rest_Tokens>>
    ']' E.Rest_Tokens +
        = (E.Rest_Tokens)      

Parser_Aux
    E.Prev_Tokens (E.Rest_Tokens) +
        = (E.Prev_Tokens) <Parser E.Rest_Tokens>

* <Interpretator W.Node*> == 
* W.Node ::= S(/Next/ /Prev/ /Inc/ /Dec/ /Write/ /Read/).Leaf | (W.Node*)
Interpretator
    E.Parsing_Tree +
        = <Interpretator_Aux <Step_Interpretator E.Parsing_Tree () /0/ ()>>

Interpretator_Aux
    E._ = 

Step_Interpretator
    /Next/ E.Rest_Parsing_Tree (E.Cells_B) S.Cell () +
        = <Step_Interpretator E.Rest_Parsing_Tree (E.Cells_B S.Cell) /0/ ()>
    /Next/ E.Rest_Parsing_Tree (E.Cells_B) S.Cell (S.Next_Cell E.Cells_A) +
        = <Step_Interpretator +
        E.Rest_Parsing_Tree (E.Cells_B S.Cell) S.Next_Cell (E.Cells_A)> 
    /Prev/ E.Rest_Parsing_Tree () S.Cell (E.Cells_A) +
        = <Step_Interpretator E.Rest_Parsing_Tree () /0/ (S.Cell E.Cells_A)>
    /Prev/ E.Rest_Parsing_Tree (E.Cells_B S.Prev_Cell) S.Cell (E.Cells_A) +
        = <Step_Interpretator +
        E.Rest_Parsing_Tree (E.Cells_B) S.Prev_Cell (S.Cell E.Cells_A)>   
    /Inc/ E._ /255/ W.Cells_A +
        = <Step_Interpretator E._ /0/ W.Cells_A>
    /Inc/ E._ S.Cell W.Cells_A +
        = <Step_Interpretator E._ <P1 S.Cell> W.Cells_A>     							
    /Dec/ E._ /0/ W.Cells_A +
        = <Step_Interpretator E._ /255/ W.Cells_A>
    /Dec/ E._ S.Cell W.Cells_A +
        = <Step_Interpretator E._ <M1 S.Cell> W.Cells_A>   
    /Write/ E._ S.Cell W.Cells_A +
        = <Put_Char S.Cell> +
        <Step_Interpretator E._ S.Cell W.Cells_A>												
    /Read/ E._ S.__ W.Cells_A +
        = <Step_Interpretator E._ <Get_Char> W.Cells_A>					
    W.Node E.Rest_Parsing_Tree W.Cells_B /0/ W.Cells_A +
        = <Step_Interpretator E.Rest_Parsing_Tree W.Cells_B /0/ W.Cells_A>
    (E.Node) E.Rest_Parsing_Tree W.Cells_B S.Cell W.Cells_A +
        = <Step_Interpretator (E.Node) E.Rest_Parsing_Tree +
        <Step_Interpretator E.Node W.Cells_B S.Cell W.Cells_A>>
    E._ = E._

    END
